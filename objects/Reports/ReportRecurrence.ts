import { DATE, ID, JSON_DATE, JSON_NUMBER, WEEKDAYS, WEEKDAYS_JSON, WEEKDAYS_PARSE } from "../API/Functions";
import { ISerializable } from "../API/Interfaces/ISerializable";
import { byte, ulong, ushort } from "../API/Types";
import { ReportRecurrenceType } from "./ReportRecurrenceType";

/**
 * Determines when and how often a report schedule runs automatically.
 */
export class ReportRecurrence
	implements ISerializable {
	/**
	 * 
	 * @param json 
	 */
	static fromJSON(json: any) {
		return new ReportRecurrence(
			ReportRecurrenceType[json["kind"] as ReportRecurrenceType],
			WEEKDAYS_PARSE(json["weekdays"]),
			ID(json["weekday"]),
			DATE(json["start"]),
			DATE(json["end"]),
			ID(json["iterations"]),
			ID(json["lastResult"]),
			DATE(json["nextStartDate"]),
			DATE(json["nextEndDate"]),
			DATE(json["lastStartDate"]),
			DATE(json["lastEndDate"])
		);
	}

	/**
	 * How often the report is automatically run.  Daily, weekly, monthly, etc...
	 */
	kind: ReportRecurrenceType = ReportRecurrenceType.once;
	/**
	 * Used only for daily schedules, this 7 item, boolean array, determines if the schedule should recur on that day of the week.
	 *  <override count="7" />
	 */
	weekdays: boolean[] = [];
	/**
	 * Used only for weekly schedules, it's a number between 0 and 6 representing the day of the week, with Sunday being the first day of the week.
	 */
	weekday: byte = NaN;
	/**
	 * When the schedule is to begin recurring in local-time (not UTC).
	 */
	start: Date = DATE();
	/**
	 * The optional time when the schedule stops recurring in local-time (not UTC).
	 */
	end: Date = DATE();

	// keeping track of progress
	/**
	 * The number of times this schedule has been invoked to generate results.
	 *  <override readonly="true" />
	 */
	iterations: ushort = NaN;
	/**
	 * The unique identifier of the last ReportResult generated by this schedule.
	 *  <override readonly="true" />
	 */
	lastResult: ulong = NaN;
	/**
	 * This date/time is used as the startDate ReportParameter for the next iteration of this recurring report.
	 * This value is null when the schedule is calculated to stop recurring.
	 *  <override readonly="true" />
	 */
	nextStartDate: Date = DATE();
	/**
	 * This date/time is used as the endDate ReportParameter for the next iteration of this recurring report.
	 * This value is null when the schedule is calculated to stop recurring.
	 *  <override readonly="true" />
	 */
	nextEndDate: Date = DATE();
	/**
	 * The date/time stamp from the last result used to inform the nextStartDate and nextEndDate properties.
	 * This value is null when the schedule has not yet run once.
	 *  <override readonly="true" />
	 */
	lastStartDate: Date = DATE();
	/**
	 * The date/time stamp from the last result used to inform the nextStartDate and nextEndDate properties.
	 * This value is null when the schedule has not yet run once.
	 *  <override readonly="true" />
	 */
	lastEndDate: Date = DATE();

	constructor(
		kind?: ReportRecurrenceType,
		weekdays?: boolean[] | string,
		weekday?: byte,
		start?: Date | number | string,
		end?: Date | number | string,
		iterations?: ushort,
		lastResult?: ulong,
		nextStartDate?: Date | number | string,
		nextEndDate?: Date | number | string,
		lastStartDate?: Date | number | string,
		lastEndDate?: Date | number | string
	) {
		this.kind = ReportRecurrenceType[kind as ReportRecurrenceType] || ReportRecurrenceType.once;
		this.weekdays = WEEKDAYS_PARSE(weekdays || WEEKDAYS);
		this.weekday = ID(weekday);
		this.start = DATE(start);
		this.end = DATE(end);
		this.iterations = ID(iterations);
		this.lastResult = ID(lastResult);
		this.nextStartDate = DATE(nextStartDate);
		this.nextEndDate = DATE(nextEndDate);
		this.lastStartDate = DATE(lastStartDate);
		this.lastEndDate = DATE(lastEndDate);
	}

	toJSON() {
		return {
			"kind": ReportRecurrenceType[this.kind] || ReportRecurrenceType.once,
			"weekdays": WEEKDAYS_JSON(this.weekdays),
			"weekday": JSON_NUMBER(this.weekday),
			"start": JSON_DATE(this.start),
			"end": JSON_DATE(this.end),
			"iterations": JSON_NUMBER(this.iterations),
			"lastResult": JSON_NUMBER(this.lastResult),
			"nextStartDate": JSON_DATE(this.nextStartDate),
			"nextEndDate": JSON_DATE(this.nextEndDate),
			"lastStartDate": JSON_DATE(this.lastStartDate),
			"lastEndDate": JSON_DATE(this.lastEndDate),
		}
	}
}